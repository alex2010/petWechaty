// Generated by CoffeeScript 2.3.2
var dly,
  indexOf = [].indexOf;

dly = util.dly;

module.exports = async function(pre, app, bot, c, qiniu) {
  var AgentOp, Ty, addFriend, alex, bigGroup, bjGroup, checkAndAddGroup, cleanRoom, code, drGroup, drRm, e, evtGroup, evtLink, evtRm, exGroup, fRoom, fcRoom, groupSay, inGroup, initList, makeAnnounce, nf, petQr, picUrl, pickContact, pickContactId, pickRoom, saveActQrcode, saveQrCode, sendGroupMsg, sendPicTxt, smGroup, smRm, testGroup, uSession, urlLink;
  code = c.code;
  ({pickRoom, fRoom, fcRoom, addFriend, pickContact, pickContactId, saveQrCode, sendPicTxt, makeAnnounce, groupSay, sendGroupMsg, urlLink, cleanRoom, initList} = require('./lib')(c, bot, qiniu));
  ({bigGroup, inGroup, exGroup, smGroup, evtGroup, bjGroup, drGroup, testGroup, petQr} = require('./def'));
  picUrl = cf._qnSetHref(util.qnUrl('show', '8444042109959.jpg'));
  evtLink = urlLink('PET Weekly Events', 'PET ä¸€å‘¨æ´»åŠ¨æ±‡æ€»', picUrl, 'http://postenglishtime.com/wm');
  app.post(`${pre}evt/salonInfo`, async function(req, rsp) {
    var ao, bo, u;
    bo = req.body;
    u = (await bot.Contact.find({
      name: bo.user.username
    }));
    if (u) {
      ao = (await dao.one(code, 'agentOp', {
        code: 'host salon'
      }));
      await u.say(ao.content);
      await u.say('è¯·åœ¨ä¸‹é¢å…¬å·é‡Œé¢è¾“å…¥ï¼šhostï¼ŒæŒ‰ç…§æç¤ºå½•å…¥è¯é¢˜å°±è¡Œã€‚ä¸ªäººä¿¡æ¯ä¸€å®šè¦å¡«å†™ï¼šè¡Œä¸šï¼ŒèŒä½ï¼Œä¸ªäººä»‹ç»ï¼Œè¿™äº›ä¼šåœ¨å‘¨ä¸€æ—¶å‘å…¬å·ï¼Œå¦‚æœæ¢ç…§ç‰‡ï¼Œåœ¨ä¸ªäººç…§ç‰‡é‡Œä¸Šä¼ ï¼Œå–ç¬¬ä¸€å¼ ã€‚');
    }
    return rsp.json({
      msg: 'ok'
    });
  });
  app.post(`${pre}evt/actPubNow`, async function(req, rsp) {
    var act, bo, msg, pic;
    bo = req.body;
    act = (await dao.one(code, 'activity', {
      _id: oid(bo.aid)
    }));
    if (act) {
      pic = util.refFile(act, 'ad');
      msg = act.adStr || act.brief;
      if (bo.group === 'allAnn') {
        await makeAnnounce(bigGroup, msg, pic);
        await groupSay([...inGroup, ...exGroup], msg, pic);
      } else if (bo.group === 'all') {
        await groupSay([...bigGroup, ...inGroup, ...exGroup], msg, pic);
      } else if (bo.group) {
        await groupSay(bo.group, msg, pic);
      }
    }
    return rsp.json({
      msg: 'ok'
    });
  });
  app.post(`${pre}evt/pubNow`, async function(req, rsp) {
    var bo;
    bo = req.body;
    if (bo.text) {
      if (bo.ann === 'all') {
        await makeAnnounce(bigGroup, bo.brief, bo.pic);
        await groupSay([...inGroup, ...exGroup], bo.brief, bo.pic);
      }
      if (bo.ann) {
        await makeAnnounce(bo.ann.split(','), bo.text, bo.url);
      }
      if (bo.say) {
        await groupSay(bo.say.ann.split(','), bo.text, bo.url);
      }
      return rsp.json({
        msg: 'ok'
      });
    }
  });
  app.post(`${pre}evt/toUser`, async function(req, rsp) {
    var bo, ro;
    bo = req.body;
    ro = (await pickContact(bo.wtName));
    await ro.say(bo.msg);
    return rsp.json({
      msg: 'ok'
    });
  });
  app.post(`${pre}evt/toHost`, async function(req, rsp) {
    var act, bo, msg, ro, u;
    bo = req.body;
    act = (await dao.one(code, 'activity', {
      _id: oid(bo.aid)
    }));
    if (act && act.master.length) {
      msg = act.master[0].username;
      if (u = (await pickContact(msg))) {
        await u.say('è¯·åœ¨åˆé€‚çš„æ—¶é—´è½¬å‘æœ‹å‹åœˆæˆ–è€…é‚€è¯·åˆé€‚çš„æœ‹å‹æ¥å‚åŠ ã€‚');
        await dly(2);
        await sendPicTxt(u, act.brief, util.refFile(act, 'ad'));
        ro = {
          msg: 'done: ' + msg
        };
      } else {
        ro = {
          msg: 'no name: ' + msg
        };
      }
    }
    return rsp.json(ro);
  });
  app.post(`${pre}evt/sideGroup`, async function(req, rsp) {
    var bo, i, it, j, k, len, len1, len2, lrm, ref, ref1, ref2, ref3, ref4, ref5, rm;
    bo = req.body;
    lrm = (await pickRoom(bo.group));
    rm = (await pickRoom(bo.group + '#'));
    if (rm && lrm) {
      if (bo.type === 'addAll') {
        ref = (await rm.memberAll());
        for (i = 0, len = ref.length; i < len; i++) {
          it = ref[i];
          if (!it.friend()) {
            await addFriend(it, bo.greeting);
          }
        }
      } else if ((ref1 = bo.type) === 'addToGroup' || ref1 === 'addAndRemove') {
        log('add or');
        if (bo.ann) {
          await rm.announce(bo.ann);
        }
        ref2 = (await rm.memberAll());
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          it = ref2[j];
          if (it.friend()) {
            if ((await lrm.has(it))) {
              if ((bo.type === 'addAndRemove') && (ref3 = it.name(), indexOf.call(initList, ref3) < 0)) {
                log('del: ' + it.name());
                await dly();
                await rm.del(it);
              }
            } else {
              log('add: ' + it.name());
              if (bo.greeting) {
                await it.say(bo.greeting);
                await dly();
              }
              await lrm.add(it);
            }
          } else {
            await addFriend(it, bo.greeting);
          }
        }
      } else if (bo.type === 'removeAll') {
        ref4 = (await rm.memberAll());
        for (k = 0, len2 = ref4.length; k < len2; k++) {
          it = ref4[k];
          if ((ref5 = it.name(), indexOf.call(initList, ref5) < 0)) {
            await dly();
            await rm.del(it);
          }
        }
      }
      return rsp.json({
        msg: 'ok'
      });
    } else {
      return rsp.json({
        err: true
      });
    }
  });
  app.post(`${pre}evt/sendGM`, async function(req, rsp) {
    var bo, i, it, len, ref, results, rm;
    bo = req.body;
    rm = (await pickRoom(bo.gName));
    if (rm) {
      ref = (await rm.memberAll());
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        it = ref[i];
        await dly();
        if (it.friend()) {
          if (bo.male && (it.gender() === bot.Contact.Gender.Male)) {
            results.push((await sendPicTxt(it, bo.msg, bo.img)));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  });
  saveActQrcode = async function(it) {
    var $set, e, fn, rm, scope;
    if (it.groupName) {
      rm = (await fcRoom(it.groupName, it));
      if (rm) {
        try {
          scope = 'temp';
          fn = `activity_qr_${util.randomChar(7)}.png`;
          await saveQrCode(rm, scope, fn);
          $set = {
            refFile: it.refFile
          };
          $set.refFile.groupQrcode = [util.qnUrl(scope, fn, c)];
          await dao.update(code, 'activity', {
            _id: it._id
          }, {$set});
          return `done: ${it.title}\n`;
        } catch (error) {
          e = error;
          log(e);
          return `saveError: ${it.title}\n`;
        }
      } else {
        return `no room: ${it.groupName}\n`;
      }
    } else {
      return `no groupName: ${it.groupName}\n`;
    }
  };
  app.post(`${pre}evt/genActQrcode`, async function(req, rsp) {
    var $gte, $lte, acts, bo, i, it, len, msg, q;
    bo = req.body;
    q = bo.aid ? {
      _id: oid(bo.aid)
    } : ($gte = new Date().monday(), $lte = new Date($gte.getTime() + 7 * Date.day), {
      startedDate: {$gte, $lte}
    });
    acts = (await dao.find(code, 'activity', q));
    msg = '';
    for (i = 0, len = acts.length; i < len; i++) {
      it = acts[i];
      msg += (await saveActQrcode(it));
    }
    return rsp.json({
      msg: msg
    });
  });
  //##############################################################
  AgentOp = gEnt(c.code, 'agentOp');
  nf = {
    greet: (await AgentOp.findOne({
      code: 'nfGreet'
    })),
    accept: (await AgentOp.findOne({
      code: 'nfAccept'
    })),
    event: (await AgentOp.findOne({
      code: 'nfEvent'
    })),
    mini: (await AgentOp.findOne({
      code: 'nfMini'
    })),
    groupRule: (await AgentOp.findOne({
      code: 'nfGroupRule'
    })),
    pet: (await AgentOp.findOne({
      code: 'subscribe'
    })),
    hostSalon: (await AgentOp.findOne({
      code: 'host salon'
    })),
    addTopic: (await AgentOp.findOne({
      code: 'host'
    }))
  };
  checkAndAddGroup = async function(group, greeting, clean) {
    var i, it, len, lrm, newList, oldList, ref, ref1, rm;
    lrm = (await pickRoom(group));
    rm = (await pickRoom(group + '#'));
    if (rm && lrm) {
      newList = [];
      oldList = [];
      ref = (await rm.memberAll());
      for (i = 0, len = ref.length; i < len; i++) {
        it = ref[i];
        await it.sync();
        if (it.friend()) {
          await dly();
          if ((await lrm.has(it))) {
            if (clean && (ref1 = it.name(), indexOf.call(initList, ref1) < 0)) {
              log('del: ' + it.name());
              await rm.del(it);
            }
          } else {
            log('add: ' + it.name());
            await it.say('æ‚¨å¥½ï¼Œæ„Ÿè°¢æ‚¨æ¥å‚åŠ æ´»åŠ¨ï¼Œç°åœ¨é‚€è¯·æ‚¨è¿›å…¥æˆ‘ä»¬çš„æ´»åŠ¨å¤§ç¾¤ï¼šï¼‰');
            await dly(2);
            await lrm.add(it);
            oldList.push(it.name());
          }
        } else {
          if (greeting) {
            await addFriend(it, greeting);
          }
          newList.push(it.name());
        }
      }
      return (await alex.say(`new: ${newList.join(',')}\n old: ${oldList.join(',')}`));
    }
  };
  bot.on('friendship', async function(friendship) {
    var e, tt;
    try {
      switch (friendship.type()) {
        case bot.Friendship.Type.Receive:
          log('accept friendship!');
          await friendship.accept();
          await sendPicTxt(friendship.contact(), nf.greet.content, nf.greet.imgUrl);
          tt = friendship.hello();
          if (/è±†ç“£/.test(tt) || /æ¨è/.test(tt) || /å‚åŠ /.test(tt)) {
            await evtRm.add(friendship.contact());
          }
          break;
        case bot.Friendship.Type.Confirm:
          return log('Friendship Confirm');
        case bot.Friendship.Type.Verify:
          log('Friendship Verify');
          //await dly(5)
          //await sendPicTxt friendship.contact(), nf.accept.content
          // è®¢é˜…å·äºŒç»´ç 
          // å¦‚æœä½ å¯¹æ´»åŠ¨æœ‰ç–‘é—®ï¼Œè¯·å‘é€ï¼š1ï¼Œ2ï¼Œ3
          // 1ï¼šæŠ¥åæµç¨‹ï¼Œ2ï¼šå»¶æœŸï¼Œ3ï¼šã€‚ã€‚ã€‚
          break;
      }
    } catch (error) {
      e = error;
      return log(e);
    }
  });
  uSession = null;
  Ty = bot.Message.Type;
  bot.on('message', async function(m) {
    var aos, apd, apid, cc, contact, e, evt, evtUrl, fBox, fn, fp, nfstr, nob, path, q, ref, ref1, room, sp, text, topic, username;
    if (m.self()) {
      return;
    }
    if (m.age() > 90) {
      return;
    }
    //			log('Message discarded because its TOO OLD(than 1 minute)')
    aos = global.aos;
    try {
      contact = m.from();
      text = m.text();
      room = m.room();
      if (contact) {
        username = contact.name();
      }
      if (room) {
        topic = (await room.topic());
        if (topic === testGroup) {
          return log(`Room: ${topic} Contact: ${username} Content: ${text}`);
        } else if (topic === "PET Ben Cubbage's life in QH") {
          path = util.sPath(code) + '/gShare/';
          if (username === 'Ben à½‰à½²à¼‹à½˜à¼‹à½šà½ºà¼‹à½¢à½²à½„à¼‹à¼' || username === 'æ±ªéœ„çº¢ Yuki' || username === 'alex') {
            nfstr = `gs6_${Date.now()}_${contact.payload.weixin || contact.id}`;
            if ((ref = m.type()) === Ty.Attachment || ref === Ty.Video || ref === Ty.Audio || ref === Ty.Image) {
              fBox = (await m.toFileBox());
              fn = `${nfstr}.${(fBox.name.split('.')[1])}`;
              fp = path + fn;
              await fBox.toFile(fp);
              return qiniu.upload(c, {
                scope: 'temp'
              }, fn, fp, function() {});
            } else if ((ref1 = m.type()) === Ty.Text || ref1 === Ty.Url) {
              return qiniu.put(c, {
                scope: 'temp'
              }, `${nfstr}.txt`, text, function() {
                return log('txt done');
              });
            }
          }
        } else if (topic === smGroup) {
          return (await addFriend(contact));
        }
      } else {
        if (username === 'alex') {
          if (text.startsWith('ce')) {
            q = {
              status: 2,
              startedDate: {
                $lt: new Date()
              },
              sort: {
                startedDate: -1
              }
            };
            if (evt = (await dao.one(code, 'activity', q))) {
              evtUrl = `http://${c.url}/newAct/activity/${evt._id}`;
              sp = text === 'cef' ? "#!/texas/ladder" : "#!/enroll/cs";
              await m.say(evtUrl + sp);
            }
            return;
          }
        }
        if (apid = aos[text]) {
          apd = (await dao.one(code, 'agentOp', {
            _id: apid
          }));
          cc = apd.type === 'page' ? urlLink(apd.title, apd.help, apd.imgUrl, apd.content) : apd.content;
          await m.say(cc);
          return;
        }
        nob = /æ´»åŠ¨æŠ¥å/.test(text) || /æŠ¥åæ´»åŠ¨/.test(text) ? nf.event : /å°ç¨‹åº/.test(text) ? nf.mini : /ç¾¤ç®¡ç†/.test(text) ? nf.groupRule : /åè‹±è¯­æ—¶ä»£/.test(text) ? nf.pet : null;
        if (nob) {
          await sendPicTxt(m, nob.content, nob.imgUrl);
          return;
        }
        if (/å®¢æœ/.test(text)) {
          await m.say((await pickContact(csUser)));
        } else if (/æ´»åŠ¨ç¾¤/.test(text)) {
          await evtRm.add(contact);
        } else if (/æ‚¨å¥½/.test(text) || /ä½ å¥½/.test(text) || /hi/.test(text)) {
          await m.say('hi~, æˆ‘ç°åœ¨æ¯”è¾ƒå¿™ï¼Œè¯·ç•™è¨€ï¼Œç¨åå›å¤æ‚¨ã€‚');
        } else if (/æ´»åŠ¨ä¿¡æ¯/.test(text)) {
          await m.say(evtLink);
        } else if (/æœ—è¯»è®¡åˆ’/.test(text)) {
          await drRm.add(contact);
        } else if (/aiarm/.test(text)) {
          uSession = `s::${username}`;
        } else if (/toOut/.test(text)) {
          await bot.logout();
        }
        //				else
        //					await m.say ''
        if (uSession) {
          if ((uSession === `ss::${username}`) && (cc = (await pickContact(initList[1])))) {
            m.forward(cc);
            return uSession = null;
          }
        }
      }
    } catch (error) {
      e = error;
      return log(e);
    }
  });
  require('./timer')(c, bot, qiniu);
  if (bot.logonoff()) {
    log('pet start...');
    try {
      await dly();
      evtRm = (await pickRoom(evtGroup));
      drRm = (await pickRoom(drGroup));
      smRm = (await pickRoom(smGroup));
      cf.petOwner = alex = (await pickContactId('fish_alex'));
      smRm.on('join', async function(inviteeList, inviter) {
        var i, it, len, results;
        log('sm join: ' + inviter.name());
        if (inviter.name() === 'å¯çˆ±çš„PET') {
          results = [];
          for (i = 0, len = inviteeList.length; i < len; i++) {
            it = inviteeList[i];
            if (it.friend()) {
              results.push(it.say('æ‚¨å¥½ï¼Œæˆ‘ä»¬çš„æ´»åŠ¨éœ€è¦æå‰äº¤è´¹ï¼Œæœ‰ä»€ä¹ˆé—®é¢˜ï¼Œè¯·ç»™æˆ‘ç•™è¨€ã€‚'));
            } else {
              results.push((await addFriend(it, 'æ‚¨å¥½ï¼Œæ„Ÿè°¢æŠ¥åæˆ‘ä»¬çš„æ´»åŠ¨ï¼Œæ´»åŠ¨éœ€è¦æå‰äº¤è´¹')));
            }
          }
          return results;
        }
      });
      //------------------------------

      //			log bot.userSelf()
      return ee.on('wechaty', async function(key, list, gName) {
        var et, fm;
        et = list[0];
        if (key === 'createMeeting') {
          fm = (await fRoom(gName));
          if (fm) {
            return groupSay(fm, `é‚€è¯·æ‚¨å‚åŠ è…¾è®¯ä¼šè®®\nä¼šè®®ä¸»é¢˜ï¼š${et.subject}\nä¼šè®®æ—¶é—´ï¼š${new Date(et.start_time * 1000).pattern('yyyy/MM/dd HH:mm')}-${new Date(et.end_time * 1000).pattern('HH:mm')}\n\nç‚¹å‡»é“¾æ¥ç›´æ¥åŠ å…¥ä¼šè®®ï¼š\n${et.join_url}\n\nä¼šè®® IDï¼š${et.meeting_code}\n\næ‰‹æœºä¸€é”®æ‹¨å·å…¥ä¼š\n+8675536550000,${et.meeting_code}# (ä¸­å›½å¤§é™†)\n+85230018898,,,2,${et.meeting_code}# (ä¸­å›½é¦™æ¸¯)\n\næ ¹æ®æ‚¨çš„ä½ç½®æ‹¨å·\n+8675536550000 (ä¸­å›½å¤§é™†)\n+85230018898 (ä¸­å›½é¦™æ¸¯)`);
          }
        }
      });
    } catch (error) {
      e = error;
      return log(e);
    }
  }
};

//			alex = await pickContact 'alex'
//			await alex.sync()
//			log alex
//			log bot

//			await checkAndAddGroup 'PET iRead', 'æ‚¨å¥½ï¼Œæˆ‘æ˜¯PETåè‹±è¯­æ—¶ä»£çš„å®˜æ–¹å®¢æœï¼Œæ„Ÿè°¢å‚åŠ æˆ‘ä»¬çš„æ´»åŠ¨'

//			bo =
//				group: 'PET SN Cocktail Party'
//				greeting: 'æ‚¨å¥½ï¼Œæˆ‘æ˜¯PETåè‹±è¯­æ—¶ä»£çš„å®˜æ–¹å®¢æœï¼Œæ„Ÿè°¢å‚åŠ æˆ‘ä»¬çš„æ´»åŠ¨'

//			rm = await pickRoom smGroup
//			log 'sssfdf'
//			mss = await rm.memberAll()
//			for cu in mss
//				log cu.name()
//				log isFriend = cu.friend()
//				unless isFriend
//					log 'fuxzzxcv'
//					log cu.name()
//					await dly()
//					try
//						await bot.Friendship.add cu
//					catch e
//						log e
//				unless cu.self()
//					await dly()
//					try
//						log 'del: ' + cu.name()
//						await rm.del cu
//					catch e
//						log e
//			await dly()
//			await rm.announce 'Hiæ‚¨å¥½ï¼Œè¯·æ·»åŠ alexçš„å¾®ä¿¡ï¼Œæˆ‘ä»¬çš„æ´»åŠ¨éœ€è¦æå‰äº¤è´¹ã€‚è°¢è°¢ğŸ˜€'
//			for uu in initList
//				if ux = await pickContact(uu)
//					await dly()
//					await rm.add ux
//petSNS = await bot.Contact.find name: 'PETåè‹±è¯­æ—¶ä»£'
//			await dly(5)
//			oneRoom = await pickRoom 'PET SN Cocktail Party'
//			await dly(3)
//			pcn = 0
//			if oneRoom
//				log 'send now...'
//				mss = await oneRoom.memberAll()
//				for ct in mss
//					if ct.gender() is bot.Contact.Gender.Male
//						pcn++
//						unless ct.friend()
//							log 'fuck: ' + ct.name()
//							continue
//						log pcn + '. ' + ct.name()
//						if pcn > 76
//							await dly(15)
//							str = 'Hi~ å¦‚æœæœ‰æ—¶é—´ï¼Œæœ‰éœ€è¦ï¼Œæ¬¢è¿å‚åŠ ã€PET Bilingual Speed Dating No.8 @11.10ã€‘ï¼Œå¥³å£«æŠ¥åå·²è¶…è¿‡10äººï¼Œéœ€è¦æ›´å¤šç”·å£«å‚åŠ ~ã€‚å¦‚æœä¸èƒ½å‚åŠ ï¼Œè¯·å¸®å¿™è½¬ä¸€ä¸‹ç»™æœ‰éœ€è¦çš„æœ‹å‹ï¼Œéå¸¸æ„Ÿè°¢~[Laugh]'
//							url = 'http://temp.s.postenglishtime.com/activity_ad_5dc329d3eefa1c3d8214c53c.jpg'
//							await sendPicTxt ct, str, url
//	sendTodayEvt [testGroup], new Date()
//	await sendReadMsg [testGroup], readGreet()
//alex.say 'åšæŒå¹¶æé†’ç”¨æˆ·å®Œæˆè¯é¢˜å†…å®¹å‡†å¤‡'
//	makeEarlyAnnounce()
//		makeMidAnnounce()
//put64 = (data, name, scope, pl = 'hb')->
//	ds =
//		hd: 'upload.qiniu.com' #åä¸œ
//		hb: 'upload-z1.qiniu.com' #ååŒ—
//		hn: 'upload-z2.qiniu.com' #åå—
//		bm: 'upload-na0.qiniu.com' #åŒ—ç¾

//	url = "http://#{ds[pl]}/put64/-1/key/#{name}"
//	request.debug = true
//	opt =
//		method: 'POST'
//		url: url
//		json: false
//		headers: {
//			'Content-Type': 'application/octet-stream'
//			'Authorization': 'UpToken ' + qiniu.sToken(c, {scope})
//		}
//		body: data
//	try
//		await request opt
//		return 'ok'
//	catch e
//		log 'fuck'
//		return 'err'

//		lrm = await pickRoom group
//		rm = await pickRoom group + '#'
//		if rm and lrm
//			newList = []
//			oldList = []
//			for it in await rm.memberAll()
//				await it.sync()
//				if it.friend()
//					await dly()
//					if await lrm.has(it)
//						if clean and (it.name() !in initList)
//							log 'del: ' + it.name()
//							await rm.del it
//					else
//						log 'add: ' + it.name()
//						await it.say 'æ‚¨å¥½ï¼Œæ„Ÿè°¢æ‚¨æ¥å‚åŠ æ´»åŠ¨ï¼Œç°åœ¨é‚€è¯·æ‚¨è¿›å…¥æˆ‘ä»¬çš„æ´»åŠ¨å¤§ç¾¤ï¼šï¼‰'
//						await dly(2)
//						await lrm.add it
//						oldList.push it.name()
//				else
//					if greeting
//						await addFriend it, greeting
//					newList.push it.name()
//			await alex.say "new: #{newList.join(',')}\n old: #{oldList.join(',')}"

//			if cu.friend()
//				unless await isInRoom(rm, cu)
//					rm.add cu
//			else
//				await bot.Friendship.add(cu, "æ‚¨å¥½ï¼Œæ„Ÿè°¢å‚åŠ æˆ‘ä»¬çš„æ´»åŠ¨:ï¼‰")
//			unless cu.self()
//				await rm.del cu
//		await rm.announce 'Hiæ‚¨å¥½ï¼Œè¯·æ·»åŠ alexçš„å¾®ä¿¡ï¼Œæˆ‘ä»¬çš„æ´»åŠ¨éœ€è¦æå‰äº¤è´¹ã€‚è°¢è°¢ğŸ˜€'
//		for uu in initList
//			if ux = await pickContact(uu)
//				await dly(10)
//				await rm.add ux
